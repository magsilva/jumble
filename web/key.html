<head>
<title>Jumble</title>
</head>
<body>
<h1>Jumble</h1>

Jumble is a class level mutation testing tool working in conjunction with JUnit. The purpose of mutation testing is to provide a measure of the effectiveness of test cases. A single consequential mutation is performed on the code to be tested, the corresponding test cases are then executed. If the modified code fails the tests, then this increases confidence in the tests. Conversely, if the modified code passes the tests this indicates a testing deficiency.<p>

JUnit [1] has become the <i>de facto</i> unit testing framework for the Java language. A class and its corresponding JUnit test is a sensible granularity at which to apply mutation testing. With Java it is feasible to perform mutations at either the source code or byte-code level. Jester [2] is a mutation tester operating at the source code level. While Jester proves useful, it is hampered by the costly cycle of modifying the source, compiling the source, and running the tests.<p>

Jumble is a new mutation tester operating directly on class files. It uses the byte-code engineering library (BCEL) [3] to directly modify class files thereby drastically cutting the time taken for each mutation test cycle. A modified version of JUnit is used to quickly exit the tests as soon as a unit test fails.<p>

<h2>Mutations</h2>

Jumble is capable of making a number of different of mutations:

<ul>
<li><b>Conditionals</b>: Jumble can replace any condition with its negation.  Thus, for example, the condition <tt>x &gt; y</tt> would mutate to become <tt>!(x > y)</tt>. Such mutations are not limited to simple conditionals as in <tt>if</tt> statements. They also can occur in loop conditions of <tt>while</tt>, <tt>for</tt>, and <tt>do</tt> loops and in <tt>?:</tt> ternary operations. Conditionals include arithmetic comparisons, reference comparisons, and tests for null and not-null. The mutation is effected by means of the <tt>negate()</tt> method of <b>IfInstruction</b> class of BCEL.<p>

The modification of a conditional can cause infinite looping. Jumble detects this situation by first timing the test on the unmodified code, then if the mutated code takes more than a certain multiple of this time the test is assumed to have caused infinite looping and the result is deemed to be a pass. Such results are indicated by a <tt>T</tt> in the test output.<p></li>

<li><b>Binary Arithmetic Operations</b>: Jumble can replace binary arithmetic operations for either integer or floating-point arithmetic with another operation. The replacement operation is selected according to the table below. Fixed replacements rather than random replacements are used because sometimes different operations will (correctly) produce the same result. Even when using the fixed replacements of the table such a situation can occasionally arise.<p>

<table>
<tr><th>Current</th><th>Mutation</th></tr>
<tr><td align="center"><tt>+</tt></td><td align="center"><tt>-</td></tr>
<tr><td align="center"><tt>-</tt></td><td align="center"><tt>+</td></tr>
<tr><td align="center"><tt>*</tt></td><td align="center"><tt>/</td></tr>
<tr><td align="center"><tt>/</tt></td><td align="center"><tt>*</td></tr>
<tr><td align="center"><tt>%</tt></td><td align="center"><tt>*</td></tr>
<tr><td align="center"><tt>&amp;</tt></td><td align="center"><tt>|</td></tr>
<tr><td align="center"><tt>|</tt></td><td align="center"><tt>&amp;</tt></td></tr>
<tr><td align="center"><tt>^</tt></td><td align="center"><tt>&amp;</tt></td></tr>
<tr><td align="center"><tt>&lt;&lt;</tt></td><td align="center"><tt>&gt;&gt;</td></tr>
<tr><td align="center"><tt>&gt;&gt;</tt></td><td align="center"><tt>&lt;&lt;</td></tr>
<tr><td align="center"><tt>&gt;&gt;&gt;</tt></td><td align="center"><tt>&lt;&lt;</td></tr>
</table>

<li><b>Literal Constants</b>: Jumble changes the value of literal constants used in <b>const</b> instructions and various <b>push</b> instructions. Because Jumble cannot tell from the class file whether such constants are ints, shorts, characters, bytes, or booleans, some confusion can occur when interpreting the output of these mutations. If the mutated value happens to corresponding to a printable ASCII character then this value appears in parenthesis after the numerical value. A value of 0 might also be a boolean false and a value of 1 a boolean true.</li>

<li><b>Return Values</b>: Jumble can change return values. For primitive booleans, shorts, characters, integers, floats, and doubles non-zero returns can be changed to 0 and 0 returns are changed to 1. For objects non-null returns can be changed to null; for null returns a RuntimeException is invoked (this is because Jumble cannot reliable instantiate a valid object or arbitrary type).</li>

</ul>

<h1>Key to Symbols</h1>

<table>
<tr><td><img src="bad.gif" alt="[bad]"></td><td>X, no corresponding test class was found.</td></tr>
<tr><td><img src="pointer.gif" alt="[pointer]"></td><td>No corresponding test class was found, but class possibly contains SWING/AWT code which is hard to JUnit test.</td></tr>
<tr><td><img src="0.gif" alt="[0]"></td><td>F, very lazy student.</td></tr>
<tr><td><img src="1.gif" alt="[0]"></td><td>E</td></tr>
<tr><td><img src="2.gif" alt="[0]"></td><td>D-</td></tr>
<tr><td><img src="3.gif" alt="[0]"></td><td>D</td></tr>
<tr><td><img src="4.gif" alt="[0]"></td><td>C-</td></tr>
<tr><td><img src="5.gif" alt="[0]"></td><td>C</td></tr>
<tr><td><img src="6.gif" alt="[0]"></td><td>B</td></tr>
<tr><td><img src="7.gif" alt="[0]"></td><td>A-</td></tr>
<tr><td><img src="8.gif" alt="[0]"></td><td>A</td></tr>
<tr><td><img src="9.gif" alt="[0]"></td><td>A+</td></tr>
<tr><td><img src="10.gif" alt="[0]"></td><td>A++, all mutations were detected.</td></tr>

<tr><td><img src="free.gif" alt="[0]"></td><td>Class was abstract or class did not contain any possible mutation points.</td></tr>
</table>

<h1>FAQ</h1>

<b>Jumble did not find my test class. What's going on?</b><p>

Jumble assumes the test class has the same name as the class to be tested with the word <tt>Test</tt> appended to the name. If the test class is newly written it might be missing from the file <tt>~/.jumbledb</tt> used by Jumble to speed its operation.  This file can be rebuilt by giving <tt>jumble.sh</tt> the <tt>-clean</tt> option (alternatively, you can simply delete the file and Jumble will rebuild it when it is next invoked).<p>

<b>Why does Jumble only make one mutation at a time?</b><p>

A single mutation is generally harder for a test class to detect than multiple simultaneous mutations.  Also, if multiple mutations were made there is a slight chance they would cancel each other out.<p>

<b>What does a <tt>.</tt> output mean?</b><p>

The test cases detected the mutation.<p>

<b>What does a <tt>M</tt> output mean?</b><p>

The mutation (which follows the <tt>M</tt>) was not detected by the test
cases.  This generally indicates the tests are in some way deficient.<p>

<b>What does a <tt>T</tt> output mean?</b><p>

The mutation caused the unit tests to take longer than expected
(possibly having put the code into an infinite loop).  Jumble gives
the coder the benefit of the doubt in such situations.<p>

<b>Can Jumble ever incorrectly report an arithmetic problem?</b><p>

Yes.  Certain combinations of operations and constants give the same
result for different examples.  For example,<p>

<pre>
y = x * sign;
y = x / sign;
</pre><p>

give the same result for <tt>sign = 1</tt> or <tt>sign = -1</tt>.<p>

<b>Can Jumble ever incorrectly report a conditional problem?</b><p>

Yes.  Certain pieces of code can be modified without invalidating the
code.  One example of this is where a condition is used to select
different code for performance reasons rather than correctness.
Suppose <tt>f1(x)</tt> and <tt>f2(x)</tt> compute the same function but are exhibit
different performance depending on x.  Valid code might then be<p>

<pre>
int foo(int x) {
    return x &lt; 10 ? f1(x) : f2(x);
}
</pre><p>

mutating the condition <tt>x &lt; 10</tt> would not change the correctness of the
code only the speed.  Unless there is a very sensitive speed test this
modification is likely to pass unit tests.<p>

<b>Is any code exempt from mutation?</b><p>

Jumble tries not to make mutations within assertions. Specific methods can also be excluded from testing, by default <tt>main</tt> and <tt>integrity</tt> are excluded.<p>

<b>Can I Jumble an interface?</b><p>

Not really since an interface contains no code to mutate.  Jumble will report a score of 100% for interfaces.<p>

<b>What's the situation with abstract classes?</b><p>

Confused.  At present Jumble does not test them even in situations where a test class does exist.<p>

<b>I cannot test something Jumble complains about?</b><p>

Just because something is difficult to test does not mean it is impossible to test.  Testing is generally a finite resource so it is appropriate to concentrate testing where it is most important.  At best Jumble is just another indicator of where potential weaknesses in the testing regime exist.  Difficulty in writing tests can be genuine, due to laziness (e.g. not wanting to parse standard output), or symptomatic of a poor design.<p>

There are a few situations where the limitations of Java and/or JUnit make testing hard.  These include testing GUI code, audio code, indeed any code where the JVM leaves uninterruptible threads hanging around, code which is conditional on operating system and/or native code, and out of memory conditions.  Testing algorithmic complexity can also be difficult in a reasonable time; for example, making sure your algorithm really is quadratic rather than cubic.<p>

Remember the purpose of Jumble is to identify potential problems, if after examining a failure you convince yourself there is never going to be a problem (e.g. because you have a formal proof) then the failure could be ignored.<p>

<h1>References</h1>

[1] Erich Gamma and Kent Beck, "Test Infected: Programmers Love Writing Tests", <i>The Java Report</i>, <b>3</b>, 7, 37-50, 1998.<p>

[2] Ivan Moore, "Jester: A JUnit Test Tester", <i>XP2001</i>, 2001.<p>

[3] Markus Dahm, "Byte Code Engineering with the BCEL API", <i>Freie Universit&auml;t Berlin, Institut f&uuml;r Informatik</i>, B-17-98, 2001.<p>

</body>
